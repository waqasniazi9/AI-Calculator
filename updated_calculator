import tkinter as tk
from tkinter import scrolledtext, messagebox, ttk, simpledialog
import math
import re
import json
import os
import sys
import traceback
import threading
import time
import numpy as np
from datetime import datetime
import random
from collections import deque

# --- VOICE RECOGNITION IMPORTS (using sounddevice) ---
VOICE_FEATURES_AVAILABLE = False
try:
    import speech_recognition as sr
    import sounddevice as sd
    import soundfile as sf
    VOICE_FEATURES_AVAILABLE = True
    print("Voice features: SoundDevice backend enabled")
except ImportError as e:
    print(f"Voice features disabled: {e}")
    print("Install with: pip install SpeechRecognition sounddevice soundfile")

MATPLOTLIB_AVAILABLE = False
try:
    from matplotlib.figure import Figure
    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
    MATPLOTLIB_AVAILABLE = True
except ImportError as e:
    print(f"Graphing disabled: {e}")
    print("Install with: pip install matplotlib")


class AIEnhancedCalculator:
    def __init__(self, root):
        self.root = root
        self.app_version = "v2.0-feature-pack"
        self.root.title(
            f"AI-Powered Smart Calculator {self.app_version} by Waqas Khan Niazi FIA Lahore")
        self.root.geometry("950x800")
        self.root.configure(bg='#2c3e50')

        # Initialize variables
        self.current_input = ""
        self.result = ""
        self.memory = 0
        self.history = deque(maxlen=50)
        self.is_dark_mode = True
        self.is_listening = False
        self.voice_feedback = True
        self.voice_status_text = "Voice: Ready"
        self.current_mode = "calculator"  # calculator or converter
        self.voice_max_seconds = 10
        self.voice_silence_seconds = 2.0
        self.voice_calibration_seconds = 0.6
        self.voice_min_seconds = 1.0
        self.voice_block_seconds = 0.1
        self.voice_trim_pad_seconds = 0.15
        self.voice_rms_target = 0.08
        self.voice_noise_threshold = 0.01
        self.voice_thread_active = False

        # Voice recognition setup
        if VOICE_FEATURES_AVAILABLE:
            try:
                self.recognizer = sr.Recognizer()
                self.sample_rate = 16000
                self.duration = 5
                devices = sd.query_devices()
                print(f"Available audio devices: {len(devices)}")
                self.voice_features_available = True
            except Exception as e:
                print(f"Voice initialization error: {e}")
                self.voice_features_available = False
        else:
            self.voice_features_available = False
            self.recognizer = None

        self.graphing_available = MATPLOTLIB_AVAILABLE
        self.graph_x_min = -10
        self.graph_x_max = 10
        self.graph_points = 800

        # Create GUI
        self.setup_gui()
        self.bind_keyboard_events()

    def setup_gui(self):
        # Title
        title_label = tk.Label(
            self.root,
            text=f"üé§ AI-Powered Voice Calculator {self.app_version} by Waqas Khan Niazi FIA Lahore",
            font=("Arial", 16, "bold"),
            bg='#34495e',
            fg='#ecf0f1'
        )
        title_label.pack(pady=(10, 5), fill=tk.X)

        # Mode Selection Frame
        mode_frame = tk.Frame(self.root, bg='#2c3e50')
        mode_frame.pack(fill=tk.X, padx=20, pady=(0, 10))

        tk.Button(mode_frame, text="üßÆ Calculator", command=self.switch_to_calculator,
                  bg='#3498db', fg='white', font=("Arial", 10)).pack(side=tk.LEFT, padx=5)
        tk.Button(mode_frame, text="üîÑ Converters", command=self.switch_to_converter,
                  bg='#e74c3c', fg='white', font=("Arial", 10)).pack(side=tk.LEFT, padx=5)
        tk.Button(mode_frame, text="‚öô Settings", command=self.show_settings,
                  bg='#f39c12', fg='white', font=("Arial", 10)).pack(side=tk.LEFT, padx=5)

        # Voice control frame
        voice_frame = tk.Frame(self.root, bg='#2c3e50')
        voice_frame.pack(fill=tk.X, padx=20, pady=(0, 10))

        if self.voice_features_available:
            self.voice_button = tk.Button(
                voice_frame,
                text="üé§ Start Voice Input",
                font=("Arial", 11, "bold"),
                bg='#9b59b6',
                fg='white',
                command=self.toggle_voice_input,
                height=2
            )
            self.voice_button.pack(side=tk.LEFT, padx=5,
                                   fill=tk.X, expand=True)

            tk.Button(
                voice_frame,
                text="‚è∫ Quick Record (5s)",
                font=("Arial", 9),
                bg='#3498db',
                fg='white',
                command=self.quick_record
            ).pack(side=tk.LEFT, padx=5)

            self.voice_status = tk.Label(
                voice_frame,
                text=self.voice_status_text,
                font=("Arial", 9),
                bg='#2c3e50',
                fg='#2ecc71'
            )
            self.voice_status.pack(side=tk.LEFT, padx=10)
        else:
            tk.Label(
                voice_frame,
                text="Voice features unavailable. Install: pip install SpeechRecognition sounddevice soundfile",
                font=("Arial", 9),
                bg='#e74c3c',
                fg='white',
                wraplength=400
            ).pack(fill=tk.X, pady=5)

        # Main Content Frame
        self.main_frame = tk.Frame(self.root, bg='#2c3e50')
        self.main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        # Create calculator and converter frames
        self.create_calculator_frame()
        self.create_converter_frame()

        # Show calculator by default
        self.show_calculator_frame()


def get_startup_log_path():
    if getattr(sys, 'frozen', False) and hasattr(sys, 'executable'):
        base_dir = os.path.dirname(sys.executable)
    else:
        base_dir = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_dir, 'startup.log')


def log_startup(message):
    try:
        with open(get_startup_log_path(), 'a', encoding='utf-8') as log_file:
            log_file.write(f"{datetime.now().isoformat()} - {message}\n")
    except Exception:
        pass

    def create_calculator_frame(self):
        self.calculator_frame = tk.Frame(self.main_frame, bg='#2c3e50')

        # Display frame
        display_frame = tk.Frame(self.calculator_frame, bg='#34495e')
        display_frame.pack(fill=tk.X, padx=0, pady=(0, 10))

        self.input_display = tk.Entry(
            display_frame,
            font=("Arial", 18),
            bd=5,
            relief=tk.RIDGE,
            justify=tk.RIGHT,
            bg='#ecf0f1',
            fg='#2c3e50'
        )
        self.input_display.pack(fill=tk.X, ipady=8, padx=10, pady=10)

        self.result_display = tk.Label(
            display_frame,
            text="0",
            font=("Arial", 20, "bold"),
            bg='#34495e',
            fg='#2ecc71',
            anchor=tk.E,
            height=2
        )
        self.result_display.pack(fill=tk.X, padx=10, pady=(0, 10))

        # Control buttons
        control_frame = tk.Frame(self.calculator_frame, bg='#2c3e50')
        control_frame.pack(fill=tk.X, padx=0, pady=(0, 10))

        tk.Button(control_frame, text="Clear All", command=self.clear_all,
                  bg='#e74c3c', fg='white', font=("Arial", 9)).pack(side=tk.LEFT, padx=2)
        tk.Button(control_frame, text="History", command=self.show_history,
                  bg='#3498db', fg='white', font=("Arial", 9)).pack(side=tk.LEFT, padx=2)
        tk.Button(control_frame, text="Loan/EMI", command=self.show_emi_calculator,
                  bg='#16a085', fg='white', font=("Arial", 9)).pack(side=tk.LEFT, padx=2)
        tk.Button(control_frame, text="BMI", command=self.show_bmi_calculator,
                  bg='#1abc9c', fg='white', font=("Arial", 9)).pack(side=tk.LEFT, padx=2)
        tk.Button(control_frame, text="Age", command=self.show_age_calculator,
                  bg='#8e44ad', fg='white', font=("Arial", 9)).pack(side=tk.LEFT, padx=2)
        tk.Button(control_frame, text="Currency", command=self.show_currency_converter,
                  bg='#27ae60', fg='white', font=("Arial", 9)).pack(side=tk.LEFT, padx=2)

        if self.graphing_available:
            tk.Button(control_frame, text="Graph", command=self.graph_expression,
                      bg='#1abc9c', fg='white', font=("Arial", 9)).pack(side=tk.LEFT, padx=2)

        if self.voice_features_available:
            tk.Button(control_frame, text="Voice Help", command=self.show_voice_help,
                      bg='#9b59b6', fg='white', font=("Arial", 9)).pack(side=tk.LEFT, padx=2)

        # Button frame
        button_frame = tk.Frame(self.calculator_frame, bg='#2c3e50')
        button_frame.pack(fill=tk.BOTH, expand=True, padx=0, pady=0)

        if self.voice_features_available:
            button_rows = [
                ['C', 'CE', '‚å´', '√∑', '‚àö', 'x¬≤', 'x¬≥'],
                ['7', '8', '9', '√ó', 'sin', 'cos', 'tan'],
                ['4', '5', '6', '-', 'asin', 'acos', 'atan'],
                ['1', '2', '3', '+', 'sinh', 'cosh', 'tanh'],
                ['0', '.', '¬±', '(', ')', 'œÄ', 'e'],
                ['ln', 'log', 'log2', 'exp', 'mod', 'abs', '%'],
                ['1/x', 'floor', 'ceil', '‚àõ', '^', '10^x', '2^x'],
                ['MR', 'MC', 'MS', 'M+', 'ANS', 'üé§', '=']
            ]
        else:
            button_rows = [
                ['C', 'CE', '‚å´', '√∑', '‚àö', 'x¬≤', 'x¬≥'],
                ['7', '8', '9', '√ó', 'sin', 'cos', 'tan'],
                ['4', '5', '6', '-', 'asin', 'acos', 'atan'],
                ['1', '2', '3', '+', 'sinh', 'cosh', 'tanh'],
                ['0', '.', '¬±', '(', ')', 'œÄ', 'e'],
                ['ln', 'log', 'log2', 'exp', 'mod', 'abs', '%'],
                ['1/x', 'floor', 'ceil', '‚àõ', '^', '10^x', '2^x'],
                ['MR', 'MC', 'MS', 'M+', 'ANS', '=', '']
            ]

        for row_idx, row in enumerate(button_rows):
            row_frame = tk.Frame(button_frame, bg='#2c3e50')
            row_frame.pack(fill=tk.BOTH, expand=True)

            for col_idx, text in enumerate(row):
                if text == '=':
                    btn_color = '#2ecc71'
                    text_color = 'white'
                elif text in ['C', 'CE']:
                    btn_color = '#e74c3c'
                    text_color = 'white'
                elif text in ['sin', 'cos', 'tan', 'asin', 'acos', 'atan', 'sinh', 'cosh', 'tanh',
                              '‚àö', '‚àõ', 'œÄ', 'e', 'n!', 'x¬≤', 'x¬≥', 'ln', 'log', 'log2', 'exp',
                              'mod', 'abs', '1/x', 'floor', 'ceil', '10^x', '2^x', '^', '%', 'ANS', 'üé§']:
                    btn_color = '#9b59b6'
                    text_color = 'white'
                elif text in ['M+', 'MR', 'MC', 'MS']:
                    btn_color = '#f39c12'
                    text_color = 'white'
                else:
                    btn_color = '#34495e'
                    text_color = '#ecf0f1'

                btn = tk.Button(
                    row_frame,
                    text=text,
                    font=("Arial", 12),
                    bg=btn_color,
                    fg=text_color,
                    bd=2,
                    relief=tk.RAISED,
                    command=lambda t=text: self.on_button_click(t)
                )
                btn.pack(side=tk.LEFT, fill=tk.BOTH,
                         expand=True, padx=2, pady=2)

    def create_converter_frame(self):
        self.converter_frame = tk.Frame(self.main_frame, bg='#2c3e50')

        # Converter selector
        selector_frame = tk.Frame(self.converter_frame, bg='#34495e')
        selector_frame.pack(fill=tk.X, padx=0, pady=(0, 10))

        tk.Label(selector_frame, text="Select Converter:", bg='#34495e', fg='#ecf0f1',
                 font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=10, pady=10)

        self.converter_var = tk.StringVar(value="length")
        converters = [
            ("Length", "length"), ("Weight",
                                   "weight"), ("Temperature", "temperature"),
            ("Volume", "volume"), ("Area", "area"), ("Speed", "speed"),
            ("Energy", "energy"), ("Power", "power"), ("Time", "time"),
            ("Data", "data"), ("Pressure", "pressure"), ("Angle", "angle"),
            ("Currency", "currency")
        ]

        for label, value in converters:
            tk.Radiobutton(
                selector_frame,
                text=label,
                variable=self.converter_var,
                value=value,
                command=self.update_converter,
                bg='#34495e',
                fg='#ecf0f1',
                selectcolor='#9b59b6',
                font=("Arial", 9)
            ).pack(side=tk.LEFT, padx=5, pady=10)

        # Converter content frame
        self.converter_content = tk.Frame(self.converter_frame, bg='#2c3e50')
        self.converter_content.pack(fill=tk.BOTH, expand=True, padx=0, pady=0)

        self.update_converter()

    def update_converter(self):
        # Clear previous content
        for widget in self.converter_content.winfo_children():
            widget.destroy()

        converter_type = self.converter_var.get()

        # Create appropriate converter UI
        if converter_type == "length":
            self.create_length_converter()
        elif converter_type == "weight":
            self.create_weight_converter()
        elif converter_type == "temperature":
            self.create_temperature_converter()
        elif converter_type == "volume":
            self.create_volume_converter()
        elif converter_type == "area":
            self.create_area_converter()
        elif converter_type == "speed":
            self.create_speed_converter()
        elif converter_type == "energy":
            self.create_energy_converter()
        elif converter_type == "power":
            self.create_power_converter()
        elif converter_type == "time":
            self.create_time_converter()
        elif converter_type == "data":
            self.create_data_converter()
        elif converter_type == "pressure":
            self.create_pressure_converter()
        elif converter_type == "angle":
            self.create_angle_converter()
        elif converter_type == "currency":
            self.create_currency_converter()

    def create_generic_converter(self, conversions_dict):
        """Generic converter UI for all types"""
        frame = tk.Frame(self.converter_content, bg='#2c3e50')
        frame.pack(fill=tk.BOTH, expand=True)

        # Input
        input_frame = tk.Frame(frame, bg='#34495e')
        input_frame.pack(fill=tk.X, padx=10, pady=10)

        tk.Label(input_frame, text="From:", bg='#34495e', fg='#ecf0f1',
                 font=("Arial", 10)).pack(side=tk.LEFT, padx=5)

        self.converter_input = tk.Entry(
            input_frame, font=("Arial", 12), width=15)
        self.converter_input.pack(side=tk.LEFT, padx=5)
        self.converter_input.insert(0, "0")

        tk.Label(input_frame, text="To:", bg='#34495e', fg='#ecf0f1',
                 font=("Arial", 10)).pack(side=tk.LEFT, padx=20)

        self.converter_output = tk.Entry(input_frame, font=(
            "Arial", 12), width=15, state='readonly')
        self.converter_output.pack(side=tk.LEFT, padx=5)

        # Unit selection
        units_frame = tk.Frame(frame, bg='#34495e')
        units_frame.pack(fill=tk.X, padx=10, pady=10)

        tk.Label(units_frame, text="From Unit:", bg='#34495e',
                 fg='#ecf0f1', font=("Arial", 10)).pack(side=tk.LEFT, padx=5)

        units_list = list(conversions_dict.keys())
        self.from_unit_var = tk.StringVar(value=units_list[0])
        from_combo = ttk.Combobox(units_frame, textvariable=self.from_unit_var,
                                  values=units_list, state='readonly', width=15)
        from_combo.pack(side=tk.LEFT, padx=5)

        tk.Label(units_frame, text="To Unit:", bg='#34495e',
                 fg='#ecf0f1', font=("Arial", 10)).pack(side=tk.LEFT, padx=20)

        self.to_unit_var = tk.StringVar(
            value=units_list[1] if len(units_list) > 1 else units_list[0])
        to_combo = ttk.Combobox(units_frame, textvariable=self.to_unit_var,
                                values=units_list, state='readonly', width=15)
        to_combo.pack(side=tk.LEFT, padx=5)

        # Convert button
        tk.Button(units_frame, text="Convert", command=lambda: self.perform_conversion(conversions_dict),
                  bg='#2ecc71', fg='white', font=("Arial", 10)).pack(side=tk.LEFT, padx=10)

        # Bind Enter key
        self.converter_input.bind(
            '<Return>', lambda e: self.perform_conversion(conversions_dict))

    def perform_conversion(self, conversions_dict):
        try:
            value = float(self.converter_input.get())
            from_unit = self.from_unit_var.get()
            to_unit = self.to_unit_var.get()

            # Convert to base unit first
            to_base = conversions_dict[from_unit]
            base_value = value * to_base

            # Convert from base to target unit
            from_base = conversions_dict[to_unit]
            result = base_value / from_base

            # Display result
            self.converter_output.config(state='normal')
            self.converter_output.delete(0, tk.END)
            self.converter_output.insert(
                0, f"{result:.6f}".rstrip('0').rstrip('.'))
            self.converter_output.config(state='readonly')
        except ValueError:
            messagebox.showerror("Error", "Please enter a valid number")

    def create_length_converter(self):
        conversions = {
            "Millimeter": 1,
            "Centimeter": 10,
            "Meter": 1000,
            "Kilometer": 1000000,
            "Inch": 25.4,
            "Foot": 304.8,
            "Yard": 914.4,
            "Mile": 1609344
        }
        self.create_generic_converter(conversions)

    def create_weight_converter(self):
        conversions = {
            "Milligram": 1,
            "Gram": 1000,
            "Kilogram": 1000000,
            "Ounce": 28349.5,
            "Pound": 453592,
            "Stone": 6350293,
            "Ton": 1000000000
        }
        self.create_generic_converter(conversions)

    def create_temperature_converter(self):
        frame = tk.Frame(self.converter_content, bg='#2c3e50')
        frame.pack(fill=tk.BOTH, expand=True)

        input_frame = tk.Frame(frame, bg='#34495e')
        input_frame.pack(fill=tk.X, padx=10, pady=10)

        tk.Label(input_frame, text="Temperature:", bg='#34495e',
                 fg='#ecf0f1', font=("Arial", 10)).pack(side=tk.LEFT, padx=5)

        temp_input = tk.Entry(input_frame, font=("Arial", 12), width=15)
        temp_input.pack(side=tk.LEFT, padx=5)
        temp_input.insert(0, "0")

        units_frame = tk.Frame(frame, bg='#34495e')
        units_frame.pack(fill=tk.X, padx=10, pady=10)

        tk.Label(units_frame, text="From:", bg='#34495e', fg='#ecf0f1',
                 font=("Arial", 10)).pack(side=tk.LEFT, padx=5)

        from_unit = tk.StringVar(value="Celsius")
        from_combo = ttk.Combobox(units_frame, textvariable=from_unit,
                                  values=["Celsius", "Fahrenheit", "Kelvin"], state='readonly', width=12)
        from_combo.pack(side=tk.LEFT, padx=5)

        tk.Label(units_frame, text="To:", bg='#34495e', fg='#ecf0f1',
                 font=("Arial", 10)).pack(side=tk.LEFT, padx=20)

        to_unit = tk.StringVar(value="Fahrenheit")
        to_combo = ttk.Combobox(units_frame, textvariable=to_unit,
                                values=["Celsius", "Fahrenheit", "Kelvin"], state='readonly', width=12)
        to_combo.pack(side=tk.LEFT, padx=5)

        result_label = tk.Label(
            frame, text="Result: 0", bg='#34495e', fg='#2ecc71', font=("Arial", 14, "bold"))
        result_label.pack(pady=20)

        def convert_temp():
            try:
                value = float(temp_input.get())
                f = from_unit.get()
                t = to_unit.get()

                # Convert to Celsius first
                if f == "Celsius":
                    c = value
                elif f == "Fahrenheit":
                    c = (value - 32) * 5/9
                else:  # Kelvin
                    c = value - 273.15

                # Convert to target
                if t == "Celsius":
                    result = c
                elif t == "Fahrenheit":
                    result = c * 9/5 + 32
                else:  # Kelvin
                    result = c + 273.15

                result_label.config(text=f"Result: {result:.2f}¬∞{t[0]}")
            except ValueError:
                messagebox.showerror("Error", "Please enter a valid number")

        tk.Button(units_frame, text="Convert", command=convert_temp,
                  bg='#2ecc71', fg='white', font=("Arial", 10)).pack(side=tk.LEFT, padx=10)

    def create_volume_converter(self):
        conversions = {
            "Milliliter": 1,
            "Liter": 1000,
            "Cubic Meter": 1000000,
            "Teaspoon": 4.92892,
            "Tablespoon": 14.7868,
            "Fluid Ounce": 29.5735,
            "Cup": 236.588,
            "Pint": 473.176,
            "Gallon": 3785.41
        }
        self.create_generic_converter(conversions)

    def create_area_converter(self):
        conversions = {
            "Square Millimeter": 1,
            "Square Centimeter": 100,
            "Square Meter": 1000000,
            "Hectare": 10000000000,
            "Square Inch": 645.16,
            "Square Foot": 92903,
            "Square Yard": 836127,
            "Square Mile": 2589988110976
        }
        self.create_generic_converter(conversions)

    def create_speed_converter(self):
        conversions = {
            "Meter/Second": 1,
            "Kilometer/Hour": 0.277778,
            "Mile/Hour": 0.44704,
            "Foot/Second": 0.3048,
            "Knot": 0.514444
        }
        self.create_generic_converter(conversions)

    def create_energy_converter(self):
        conversions = {
            "Joule": 1,
            "Kilojoule": 1000,
            "Calorie": 4.184,
            "Kilocalorie": 4184,
            "Watt-Hour": 3600,
            "Kilowatt-Hour": 3600000,
            "BTU": 1055.06,
            "Electronvolt": 1.60218e-19
        }
        self.create_generic_converter(conversions)

    def create_power_converter(self):
        conversions = {
            "Watt": 1,
            "Kilowatt": 1000,
            "Megawatt": 1000000,
            "Horsepower": 745.7,
            "BTU/Hour": 0.293071
        }
        self.create_generic_converter(conversions)

    def create_time_converter(self):
        conversions = {
            "Millisecond": 1,
            "Second": 1000,
            "Minute": 60000,
            "Hour": 3600000,
            "Day": 86400000,
            "Week": 604800000,
            "Month": 2592000000,
            "Year": 31536000000
        }
        self.create_generic_converter(conversions)

    def create_data_converter(self):
        conversions = {
            "Byte": 1,
            "Kilobyte": 1024,
            "Megabyte": 1048576,
            "Gigabyte": 1073741824,
            "Terabyte": 1099511627776,
            "Petabyte": 1125899906842624
        }
        self.create_generic_converter(conversions)

    def create_pressure_converter(self):
        conversions = {
            "Pascal": 1,
            "Kilopascal": 1000,
            "Bar": 100000,
            "PSI": 6894.76,
            "Atmosphere": 101325,
            "Torr": 133.322
        }
        self.create_generic_converter(conversions)

    def create_angle_converter(self):
        conversions = {
            "Degree": 1,
            "Radian": 57.2958,
            "Gradian": 0.9,
            "Minute": 60,
            "Second": 3600
        }
        self.create_generic_converter(conversions)

    def create_currency_converter(self):
        frame = tk.Frame(self.converter_content, bg='#2c3e50')
        frame.pack(fill=tk.BOTH, expand=True)

        input_frame = tk.Frame(frame, bg='#34495e')
        input_frame.pack(fill=tk.X, padx=10, pady=10)

        tk.Label(input_frame, text="Note: Currency rates are fixed for demo. Update rates in settings.",
                 bg='#34495e', fg='#f39c12', font=("Arial", 10)).pack(fill=tk.X, padx=10, pady=10)

        currencies = {
            "USD": 1,
            "EUR": 0.92,
            "GBP": 0.79,
            "PKR": 278,
            "INR": 83.12,
            "AED": 3.67,
            "SAR": 3.75,
            "CAD": 1.36,
            "AUD": 1.52,
            "JPY": 149.50
        }
        self.create_generic_converter(currencies)

    def switch_to_calculator(self):
        self.current_mode = "calculator"
        self.show_calculator_frame()

    def switch_to_converter(self):
        self.current_mode = "converter"
        self.show_converter_frame()

    def show_calculator_frame(self):
        self.converter_frame.pack_forget()
        self.calculator_frame.pack(fill=tk.BOTH, expand=True)

    def show_converter_frame(self):
        self.calculator_frame.pack_forget()
        self.converter_frame.pack(fill=tk.BOTH, expand=True)

    def show_settings(self):
        settings_window = tk.Toplevel(self.root)
        settings_window.title("‚öô Settings")
        settings_window.geometry("500x400")
        settings_window.configure(bg='#2c3e50')

        settings_text = """
        CALCULATOR & CONVERTER SETTINGS
        ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        
        CALCULATOR:
        ‚Ä¢ Decimal Precision: 10 digits
        ‚Ä¢ History Size: 50 items max
        ‚Ä¢ Memory Slots: 1
        
        CONVERTERS:
        ‚Ä¢ Length: mm, cm, m, km, inch, foot, yard, mile
        ‚Ä¢ Weight: mg, g, kg, oz, lb, stone, ton
        ‚Ä¢ Temperature: Celsius, Fahrenheit, Kelvin
        ‚Ä¢ Volume: ml, l, m¬≥, tsp, tbsp, fl oz, cup, pint, gallon
        ‚Ä¢ Area: mm¬≤, cm¬≤, m¬≤, hectare, in¬≤, ft¬≤, yd¬≤, mi¬≤
        ‚Ä¢ Speed: m/s, km/h, mph, ft/s, knot
        ‚Ä¢ Energy: J, kJ, cal, kcal, Wh, kWh, BTU, eV
        ‚Ä¢ Power: W, kW, MW, hp, BTU/hr
        ‚Ä¢ Time: ms, sec, min, hr, day, week, month, year
        ‚Ä¢ Data: Byte, KB, MB, GB, TB, PB
        ‚Ä¢ Pressure: Pa, kPa, bar, PSI, atm, torr
        ‚Ä¢ Angle: degree, radian, gradian, minute, second
        ‚Ä¢ Currency: USD, EUR, GBP, PKR, INR, AED, SAR, CAD, AUD, JPY
        
        VOICE:
        ‚Ä¢ Command Recognition via Google API
        ‚Ä¢ Support for voice in Calculator mode
        
        For more info, click "Voice Help" in main window.
        """

        text_widget = scrolledtext.ScrolledText(
            settings_window,
            wrap=tk.WORD,
            font=("Consolas", 9),
            bg='#34495e',
            fg='#ecf0f1',
            height=20
        )
        text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        text_widget.insert(tk.END, settings_text)
        text_widget.config(state=tk.DISABLED)

        tk.Button(settings_window, text="Close", command=settings_window.destroy,
                  bg='#3498db', fg='white').pack(pady=10)

    def show_currency_converter(self):
        self.converter_var.set("currency")
        self.update_converter()
        self.show_converter_frame()

    def show_emi_calculator(self):
        emi_window = tk.Toplevel(self.root)
        emi_window.title("Loan / EMI Calculator")
        emi_window.geometry("420x320")
        emi_window.configure(bg='#2c3e50')

        tk.Label(emi_window, text="Loan / EMI Calculator",
                 font=("Arial", 12, "bold"), bg='#34495e', fg='#ecf0f1').pack(fill=tk.X, pady=(10, 5))

        form = tk.Frame(emi_window, bg='#2c3e50')
        form.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)

        tk.Label(form, text="Principal:", bg='#2c3e50', fg='#ecf0f1').grid(
            row=0, column=0, sticky='w', pady=6)
        principal_entry = tk.Entry(form, font=("Arial", 11))
        principal_entry.grid(row=0, column=1, padx=8, pady=6)

        tk.Label(form, text="Annual rate (%):", bg='#2c3e50',
                 fg='#ecf0f1').grid(row=1, column=0, sticky='w', pady=6)
        rate_entry = tk.Entry(form, font=("Arial", 11))
        rate_entry.grid(row=1, column=1, padx=8, pady=6)

        tk.Label(form, text="Years:", bg='#2c3e50', fg='#ecf0f1').grid(
            row=2, column=0, sticky='w', pady=6)
        years_entry = tk.Entry(form, font=("Arial", 11))
        years_entry.grid(row=2, column=1, padx=8, pady=6)

        result_label = tk.Label(form, text="Monthly EMI: -",
                                bg='#2c3e50', fg='#2ecc71', font=("Arial", 11, "bold"))
        result_label.grid(row=3, column=0, columnspan=2, pady=(12, 4))

        total_label = tk.Label(form, text="Total Payment: -",
                               bg='#2c3e50', fg='#ecf0f1', font=("Arial", 10))
        total_label.grid(row=4, column=0, columnspan=2, pady=2)

        interest_label = tk.Label(
            form, text="Total Interest: -", bg='#2c3e50', fg='#ecf0f1', font=("Arial", 10))
        interest_label.grid(row=5, column=0, columnspan=2, pady=2)

        def calculate_emi():
            try:
                principal = float(principal_entry.get())
                annual_rate = float(rate_entry.get())
                years = float(years_entry.get())
                if principal <= 0 or annual_rate < 0 or years <= 0:
                    raise ValueError()
                months = int(round(years * 12))
                monthly_rate = (annual_rate / 100.0) / 12.0
                if monthly_rate == 0:
                    emi = principal / months
                else:
                    factor = (1 + monthly_rate) ** months
                    emi = principal * monthly_rate * factor / (factor - 1)

                total_payment = emi * months
                total_interest = total_payment - principal

                result_label.config(text=f"Monthly EMI: {emi:.2f}")
                total_label.config(text=f"Total Payment: {total_payment:.2f}")
                interest_label.config(
                    text=f"Total Interest: {total_interest:.2f}")
            except Exception:
                messagebox.showerror("Error", "Please enter valid loan values")

        tk.Button(form, text="Calculate", command=calculate_emi,
                  bg='#2ecc71', fg='white', font=("Arial", 10)).grid(row=6, column=0, columnspan=2, pady=10)

    def show_bmi_calculator(self):
        bmi_window = tk.Toplevel(self.root)
        bmi_window.title("BMI Calculator")
        bmi_window.geometry("400x260")
        bmi_window.configure(bg='#2c3e50')

        tk.Label(bmi_window, text="Body Mass Index (BMI)",
                 font=("Arial", 12, "bold"), bg='#34495e', fg='#ecf0f1').pack(fill=tk.X, pady=(10, 5))

        form = tk.Frame(bmi_window, bg='#2c3e50')
        form.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)

        tk.Label(form, text="Weight (kg):", bg='#2c3e50', fg='#ecf0f1').grid(
            row=0, column=0, sticky='w', pady=6)
        weight_entry = tk.Entry(form, font=("Arial", 11))
        weight_entry.grid(row=0, column=1, padx=8, pady=6)

        tk.Label(form, text="Height (cm):", bg='#2c3e50', fg='#ecf0f1').grid(
            row=1, column=0, sticky='w', pady=6)
        height_entry = tk.Entry(form, font=("Arial", 11))
        height_entry.grid(row=1, column=1, padx=8, pady=6)

        result_label = tk.Label(
            form, text="BMI: -", bg='#2c3e50', fg='#2ecc71', font=("Arial", 11, "bold"))
        result_label.grid(row=2, column=0, columnspan=2, pady=(12, 6))

        def calculate_bmi():
            try:
                weight = float(weight_entry.get())
                height_cm = float(height_entry.get())
                if weight <= 0 or height_cm <= 0:
                    raise ValueError()
                height_m = height_cm / 100.0
                bmi = weight / (height_m ** 2)
                category = "Normal"
                if bmi < 18.5:
                    category = "Underweight"
                elif bmi < 25:
                    category = "Normal"
                elif bmi < 30:
                    category = "Overweight"
                else:
                    category = "Obese"
                result_label.config(text=f"BMI: {bmi:.2f} ({category})")
            except Exception:
                messagebox.showerror(
                    "Error", "Please enter valid weight and height")

        tk.Button(form, text="Calculate", command=calculate_bmi,
                  bg='#2ecc71', fg='white', font=("Arial", 10)).grid(row=3, column=0, columnspan=2, pady=8)

    def show_age_calculator(self):
        age_window = tk.Toplevel(self.root)
        age_window.title("Age Calculator")
        age_window.geometry("420x280")
        age_window.configure(bg='#2c3e50')

        tk.Label(age_window, text="Age Calculator", font=("Arial", 12, "bold"),
                 bg='#34495e', fg='#ecf0f1').pack(fill=tk.X, pady=(10, 5))

        form = tk.Frame(age_window, bg='#2c3e50')
        form.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)

        tk.Label(form, text="Birth date (YYYY-MM-DD):", bg='#2c3e50', fg='#ecf0f1').grid(
            row=0, column=0, sticky='w', pady=6)
        birth_entry = tk.Entry(form, font=("Arial", 11), width=16)
        birth_entry.grid(row=0, column=1, padx=8, pady=6)

        tk.Label(form, text="As of date (YYYY-MM-DD):", bg='#2c3e50', fg='#ecf0f1').grid(
            row=1, column=0, sticky='w', pady=6)
        as_of_entry = tk.Entry(form, font=("Arial", 11), width=16)
        as_of_entry.grid(row=1, column=1, padx=8, pady=6)
        as_of_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))

        result_label = tk.Label(
            form, text="Age: -", bg='#2c3e50', fg='#2ecc71', font=("Arial", 11, "bold"))
        result_label.grid(row=2, column=0, columnspan=2, pady=(12, 6))

        def days_in_month(year, month):
            if month == 12:
                next_month = datetime(year + 1, 1, 1)
            else:
                next_month = datetime(year, month + 1, 1)
            return (next_month - datetime(year, month, 1)).days

        def calculate_age():
            try:
                birth = datetime.strptime(
                    birth_entry.get().strip(), "%Y-%m-%d")
                as_of = datetime.strptime(
                    as_of_entry.get().strip(), "%Y-%m-%d")
                if as_of < birth:
                    messagebox.showerror(
                        "Error", "As-of date must be after birth date")
                    return

                years = as_of.year - birth.year
                if (as_of.month, as_of.day) < (birth.month, birth.day):
                    years -= 1

                months = as_of.month - birth.month
                if as_of.day < birth.day:
                    months -= 1
                if months < 0:
                    months += 12

                days = as_of.day - birth.day
                if days < 0:
                    prev_month = as_of.month - 1
                    prev_year = as_of.year
                    if prev_month == 0:
                        prev_month = 12
                        prev_year -= 1
                    days += days_in_month(prev_year, prev_month)

                result_label.config(text=f"Age: {years}y {months}m {days}d")
            except Exception:
                messagebox.showerror(
                    "Error", "Please enter dates as YYYY-MM-DD")

        tk.Button(form, text="Calculate", command=calculate_age,
                  bg='#2ecc71', fg='white', font=("Arial", 10)).grid(row=3, column=0, columnspan=2, pady=8)

    # --- VOICE FUNCTIONS ---

    def toggle_voice_input(self):
        if not self.voice_features_available or self.current_mode != "calculator":
            messagebox.showerror(
                "Error", "Voice only works in Calculator mode")
            return

        if not self.is_listening:
            if self.voice_thread_active:
                return
            self.is_listening = True
            self.voice_button.config(text="‚è∏ Stop Recording", bg='#e74c3c')
            self.voice_status.config(
                text="Listening... Speak now", fg='#f1c40f')

            voice_thread = threading.Thread(target=self.record_and_process)
            voice_thread.daemon = True
            voice_thread.start()
        else:
            self.is_listening = False
            self.voice_button.config(text="üé§ Start Voice Input", bg='#9b59b6')
            self.voice_status.config(text="Voice: Ready", fg='#2ecc71')

    def quick_record(self):
        if not self.voice_features_available or self.current_mode != "calculator":
            return

        if self.is_listening:
            return

        if self.voice_thread_active:
            return

        self.is_listening = True
        self.voice_button.config(text="‚è∏ Stop Recording", bg='#e74c3c')
        self.voice_status.config(text="Recording 5 seconds...", fg='#f1c40f')
        self.root.update()

        record_thread = threading.Thread(
            target=self.record_fixed_duration, args=(5,))
        record_thread.daemon = True
        record_thread.start()

    def record_fixed_duration(self, seconds):
        try:
            self.voice_thread_active = True
            recording = sd.rec(int(seconds * self.sample_rate),
                               samplerate=self.sample_rate,
                               channels=1,
                               dtype='float32')

            for i in range(seconds, 0, -1):
                if not self.is_listening:
                    sd.stop()
                    return
                self.root.after(0, lambda i=i: self.voice_status.config(
                    text=f"Recording... {i}s", fg='#f1c40f'))
                time.sleep(1)

            sd.wait()

            audio_data = np.squeeze(recording)
            self.process_audio_data(audio_data)

        except Exception as e:
            self.root.after(0, lambda: self.voice_status.config(
                text=f"Error: {str(e)[:30]}", fg='#e74c3c'))
        finally:
            self.is_listening = False
            self.voice_thread_active = False
            self.root.after(0, lambda: self.voice_button.config(
                text="üé§ Start Voice Input", bg='#9b59b6'))

    def record_and_process(self):
        try:
            self.voice_thread_active = True
            audio_chunks = []
            start_time = time.time()
            noise_threshold = self.calibrate_noise_threshold()
            last_update_second = -1
            silence_frames = 0
            last_rms = 0.0
            rms_window = deque(maxlen=5)
            block_size = int(self.sample_rate * self.voice_block_seconds)
            silence_limit = max(
                1, int(self.voice_silence_seconds / self.voice_block_seconds))
            stop_reason = None

            def audio_callback(indata, frames, time_info, status):
                nonlocal silence_frames, last_rms, stop_reason
                if status:
                    print(f"Audio status: {status}")
                audio_chunks.append(indata.copy())
                rms = float(np.sqrt(np.mean(indata ** 2)))
                rms_window.append(rms)
                last_rms = float(sum(rms_window) /
                                 len(rms_window)) if rms_window else rms
                if last_rms > noise_threshold:
                    silence_frames = 0
                else:
                    silence_frames += 1

                elapsed = time.time() - start_time
                if elapsed >= self.voice_min_seconds and silence_frames >= silence_limit:
                    stop_reason = "silence"
                    self.is_listening = False

            with sd.InputStream(samplerate=self.sample_rate,
                                channels=1,
                                dtype='float32',
                                blocksize=block_size,
                                callback=audio_callback):
                while self.is_listening:
                    elapsed = time.time() - start_time
                    remaining = max(0, int(self.voice_max_seconds - elapsed))
                    elapsed_int = int(elapsed)
                    if elapsed_int != last_update_second:
                        last_update_second = elapsed_int
                        self.root.after(0, lambda e=elapsed_int, r=remaining: self.voice_status.config(
                            text=f"Listening... {e}s (auto-stop in {r}s)", fg='#f1c40f'))

                    if elapsed >= self.voice_max_seconds:
                        stop_reason = "max"
                        self.is_listening = False
                        break

                    time.sleep(0.1)

            if audio_chunks:
                complete_audio = np.concatenate(audio_chunks, axis=0)
                self.is_listening = False
                self.root.after(0, lambda: self.voice_button.config(
                    text="üé§ Start Voice Input", bg='#9b59b6'))
                if stop_reason == "silence":
                    self.root.after(0, lambda: self.voice_status.config(
                        text="Auto-stopped (silence)", fg='#f39c12'))
                elif stop_reason == "max":
                    self.root.after(0, lambda: self.voice_status.config(
                        text="Auto-stopped (time limit)", fg='#f39c12'))
                else:
                    self.root.after(0, lambda: self.voice_status.config(
                        text="Processing audio...", fg='#f39c12'))
                self.process_audio_data(complete_audio)
            else:
                self.is_listening = False
                self.root.after(0, lambda: self.voice_button.config(
                    text="üé§ Start Voice Input", bg='#9b59b6'))
                self.root.after(0, lambda: self.voice_status.config(
                    text="No audio captured", fg='#e74c3c'))

        except Exception as e:
            self.root.after(0, lambda: self.voice_status.config(
                text=f"Recording error: {str(e)[:30]}", fg='#e74c3c'))
            self.is_listening = False
            self.root.after(0, lambda: self.voice_button.config(
                text="üé§ Start Voice Input", bg='#9b59b6'))
            print(f"Recording error: {e}")
        finally:
            self.voice_thread_active = False

    def calibrate_noise_threshold(self):
        try:
            self.root.after(0, lambda: self.voice_status.config(
                text="Calibrating noise...", fg='#f1c40f'))
            recording = sd.rec(int(self.voice_calibration_seconds * self.sample_rate),
                               samplerate=self.sample_rate,
                               channels=1,
                               dtype='float32')
            sd.wait()
            audio = np.squeeze(recording)
            if audio.size == 0:
                return 0.01
            rms = float(np.sqrt(np.mean(np.square(audio))))
            threshold = max(rms * 2.5, 0.01)
            self.voice_noise_threshold = threshold
            if self.recognizer:
                self.recognizer.energy_threshold = threshold * 32767
                self.recognizer.dynamic_energy_threshold = False
            return threshold
        except Exception as e:
            print(f"Calibration error: {e}")
            return 0.01

    def preprocess_audio_data(self, audio_data):
        noise_threshold = max(self.voice_noise_threshold, 0.01)
        trim_threshold = noise_threshold * 1.3
        abs_audio = np.abs(audio_data)
        voiced = np.where(abs_audio > trim_threshold)[0]
        if voiced.size > 0:
            pad = int(self.sample_rate * self.voice_trim_pad_seconds)
            start = max(0, int(voiced[0]) - pad)
            end = min(len(audio_data), int(voiced[-1]) + pad + 1)
            audio_data = audio_data[start:end]

        if audio_data.size == 0:
            return audio_data

        rms = float(np.sqrt(np.mean(np.square(audio_data))))
        if rms > 0:
            gain = self.voice_rms_target / rms
            audio_data = np.clip(audio_data * gain, -1.0, 1.0)

        return audio_data

    def process_audio_data(self, audio_data):
        try:
            if audio_data.dtype != np.float32:
                audio_data = audio_data.astype(np.float32)

            audio_data = np.squeeze(audio_data)
            audio_data = self.preprocess_audio_data(audio_data)

            if len(audio_data) < self.sample_rate * 0.5:
                self.root.after(0, lambda: self.voice_status.config(
                    text="Audio too short, try again", fg='#e74c3c'))
                return

            self.root.after(0, lambda: self.voice_status.config(
                text="Processing audio...", fg='#f39c12'))

            int16_audio = np.clip(audio_data, -1.0, 1.0)
            int16_audio = (int16_audio * 32767).astype(np.int16)
            audio = sr.AudioData(int16_audio.tobytes(), self.sample_rate, 2)
            text = self.recognizer.recognize_google(audio)

            self.root.after(0, lambda t=text: self.handle_recognized_speech(t))

        except sr.UnknownValueError:
            self.root.after(0, lambda: self.voice_status.config(
                text="Could not understand audio", fg='#e74c3c'))
        except sr.RequestError as e:
            self.root.after(0, lambda: self.voice_status.config(
                text="Internet/API Error - Check connection", fg='#e74c3c'))
            print(f"API Error: {e}")
        except Exception as e:
            self.root.after(0, lambda: self.voice_status.config(
                text=f"Error: {str(e)[:30]}", fg='#e74c3c'))
            print(f"Error: {e}")
        finally:
            pass

    def handle_recognized_speech(self, text):
        display_text = text[:40] + "..." if len(text) > 40 else text
        self.voice_status.config(text=f"Heard: {display_text}", fg='#3498db')

        converted_text = self.convert_speech_to_math(text.lower())
        self.add_to_input(converted_text)

        if '=' in converted_text or 'equals' in text.lower():
            self.root.after(500, self.calculate)

    def convert_speech_to_math(self, text):
        text = self.replace_number_words(text.lower())
        conversions = {
            r'\bplus\b|\+': '+',
            r'\bminus\b|\-': '-',
            r'\btimes\b|\bmultiplied by\b|\*': '√ó',
            r'\bdivided by\b|\bover\b|/': '√∑',
            r'\bsquared\b|\^2': '**2',
            r'\bcubed\b|\^3': '**3',
            r'\bto the power of\b|\bpower of\b|\braised to\b|\^': '**',

            r'\bzero\b': '0', r'\bone\b': '1', r'\btwo\b': '2', r'\bthree\b': '3',
            r'\bfour\b': '4', r'\bfive\b': '5', r'\bsix\b': '6', r'\bseven\b': '7',
            r'\beight\b': '8', r'\bnine\b': '9', r'\bten\b': '10',

            r'\bsquare root of\b|\broot of\b': 'sqrt(',
            r'\bcube root of\b|\bcubic root of\b': 'cbrt(',
            r'\bsine of\b|\bsin of\b': 'sin(',
            r'\bcosine of\b|\bcos of\b': 'cos(',
            r'\btangent of\b|\btan of\b': 'tan(',
            r'\barcsin\b|\binverse sine\b|\basin of\b': 'asin(',
            r'\barccos\b|\binverse cosine\b|\bacos of\b': 'acos(',
            r'\barctan\b|\binverse tangent\b|\batan of\b': 'atan(',
            r'\bhyperbolic sine\b|\bsinh of\b': 'sinh(',
            r'\bhyperbolic cosine\b|\bcosh of\b': 'cosh(',
            r'\bhyperbolic tangent\b|\btanh of\b': 'tanh(',
            r'\bnatural log\b|\bln of\b': 'ln(',
            r'\blog base 2\b|\bbinary log\b|\blog2 of\b': 'log2(',
            r'\blog of\b|\blogarithm of\b': 'log10(',
            r'\bexp\b|\bexponential\b': 'exp(',
            r'\babsolute value of\b|\babsolute\b': 'abs(',
            r'\bfloor of\b|\bfloor\b': 'floor(',
            r'\bceiling of\b|\bceiling\b|\bceil\b': 'ceil(',
            r'\bfactorial of\b|\bfactorial\b': 'factorial(',

            r'\bpi\b|\bpie\b': str(math.pi),
            r'\be\b|\beuler\b': str(math.e),

            r'\bequals\b|\bequal\b|\bcalculate\b': '=',
            r'\bclear\b|\breset\b': 'C',
            r'\bbackspace\b|\bdelete\b': '‚å´',
            r'\bopen bracket\b|\bopen parenthesis\b': '(',
            r'\bclose bracket\b|\bclose parenthesis\b': ')',
            r'\bpoint\b|\bdecimal\b': '.',
            r'\bpercent\b|\bpercentage\b': '/100',
            r'\bmod\b|\bmodulo\b|\bmodulus\b': '%',
        }

        result = text
        for pattern, replacement in conversions.items():
            result = re.sub(pattern, replacement, result, flags=re.IGNORECASE)

        result = re.sub(r'\b(what is|compute|calculate|find|the|of|and|please)\b',
                        '', result, flags=re.IGNORECASE)
        result = re.sub(r'\s+', ' ', result).strip()

        return result + ' '

    def replace_number_words(self, text):
        text = text.replace('-', ' ')
        tokens = re.findall(r"[A-Za-z]+|\d+|\S", text)
        out = []
        i = 0
        while i < len(tokens):
            token = tokens[i]
            if token.isdigit():
                out.append(token)
                i += 1
                continue

            number_str, consumed = self.parse_number_sequence(tokens, i)
            if consumed > 0:
                out.append(number_str)
                i += consumed
                continue

            out.append(token)
            i += 1

        return ' '.join(out)

    def parse_number_sequence(self, tokens, start_index):
        units = {
            'zero': 0, 'oh': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,
            'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9
        }
        teens = {
            'ten': 10, 'eleven': 11, 'twelve': 12, 'thirteen': 13,
            'fourteen': 14, 'fifteen': 15, 'sixteen': 16,
            'seventeen': 17, 'eighteen': 18, 'nineteen': 19
        }
        tens = {
            'twenty': 20, 'thirty': 30, 'forty': 40, 'fifty': 50,
            'sixty': 60, 'seventy': 70, 'eighty': 80, 'ninety': 90
        }
        scales = {'hundred': 100, 'thousand': 1000, 'million': 1000000}

        total = 0
        current = 0
        consumed = 0
        has_number = False
        i = start_index

        while i < len(tokens):
            t = tokens[i].lower()
            if t in units:
                current += units[t]
                has_number = True
            elif t in teens:
                current += teens[t]
                has_number = True
            elif t in tens:
                current += tens[t]
                has_number = True
            elif t == 'hundred':
                if current == 0:
                    current = 1
                current *= scales[t]
                has_number = True
            elif t in scales:
                if current == 0:
                    current = 1
                total += current * scales[t]
                current = 0
                has_number = True
            elif t == 'and' and has_number:
                pass
            else:
                break
            consumed += 1
            i += 1

        if not has_number:
            return "", 0

        if i < len(tokens) and tokens[i].lower() in ('point', 'dot', 'decimal'):
            i += 1
            consumed += 1
            frac_digits = []
            while i < len(tokens):
                t = tokens[i].lower()
                if t in units:
                    frac_digits.append(str(units[t]))
                elif tokens[i].isdigit() and len(tokens[i]) == 1:
                    frac_digits.append(tokens[i])
                else:
                    break
                i += 1
                consumed += 1

            number = str(total + current)
            if frac_digits:
                number = number + '.' + ''.join(frac_digits)
            return number, consumed

        return str(total + current), consumed

    def show_voice_help(self):
        help_text = """
        VOICE COMMANDS:
        
        SAY THESE PHRASES:
        ‚Ä¢ "five plus three" ‚Üí 5+3
        ‚Ä¢ "ten minus four" ‚Üí 10-4
        ‚Ä¢ "six times seven" ‚Üí 6√ó7
        ‚Ä¢ "twenty divided by five" ‚Üí 20√∑5
        
        FUNCTIONS:
        ‚Ä¢ "square root of sixteen" ‚Üí sqrt(16)
        ‚Ä¢ "sine of thirty" ‚Üí sin(30)
        ‚Ä¢ "cosine of forty five" ‚Üí cos(45)
        
        CONSTANTS:
        ‚Ä¢ "pi" ‚Üí œÄ
        ‚Ä¢ "e" ‚Üí e
        
        TIPS:
        - Speak clearly and steadily
        - Use "equals" at the end to auto-calculate
        - Click "Quick Record" for easier recording
        """

        help_window = tk.Toplevel(self.root)
        help_window.title("Voice Command Help")
        help_window.geometry("500x400")
        help_window.configure(bg='#2c3e50')

        text_widget = scrolledtext.ScrolledText(
            help_window,
            wrap=tk.WORD,
            font=("Consolas", 10),
            bg='#34495e',
            fg='#ecf0f1',
            height=20
        )
        text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        text_widget.insert(tk.END, help_text)
        text_widget.config(state=tk.DISABLED)

        tk.Button(help_window, text="Close", command=help_window.destroy,
                  bg='#3498db', fg='white').pack(pady=10)

    # --- CALCULATOR FUNCTIONS ---

    def bind_keyboard_events(self):
        for i in range(10):
            self.root.bind(str(i), lambda event,
                           num=i: self.add_to_input(str(num)))

        self.root.bind('<Return>', lambda e: self.calculate())
        self.root.bind('<Escape>', lambda e: self.clear_all())
        self.root.bind('<BackSpace>', lambda e: self.backspace())
        self.root.bind('+', lambda e: self.add_to_input('+'))
        self.root.bind('-', lambda e: self.add_to_input('-'))
        self.root.bind('*', lambda e: self.add_to_input('√ó'))
        self.root.bind('/', lambda e: self.add_to_input('√∑'))
        self.root.bind('.', lambda e: self.add_to_input('.'))
        self.root.bind('(', lambda e: self.add_to_input('('))
        self.root.bind(')', lambda e: self.add_to_input(')'))
        if self.voice_features_available:
            self.root.bind('v', lambda e: self.toggle_voice_input())

    def on_button_click(self, button_text):
        if button_text == 'üé§':
            self.toggle_voice_input()
        elif button_text == '=':
            self.calculate()
        elif button_text == 'C':
            self.clear_all()
        elif button_text == 'CE':
            self.clear_entry()
        elif button_text == '‚å´':
            self.backspace()
        elif button_text == '¬±':
            self.negate()
        elif button_text == '‚àö':
            self.add_to_input('sqrt(')
        elif button_text == 'x¬≤':
            self.add_to_input('**2')
        elif button_text == 'x¬≥':
            self.add_to_input('**3')
        elif button_text == 'sin':
            self.add_to_input('sin(')
        elif button_text == 'cos':
            self.add_to_input('cos(')
        elif button_text == 'tan':
            self.add_to_input('tan(')
        elif button_text == 'asin':
            self.add_to_input('asin(')
        elif button_text == 'acos':
            self.add_to_input('acos(')
        elif button_text == 'atan':
            self.add_to_input('atan(')
        elif button_text == 'sinh':
            self.add_to_input('sinh(')
        elif button_text == 'cosh':
            self.add_to_input('cosh(')
        elif button_text == 'tanh':
            self.add_to_input('tanh(')
        elif button_text == 'œÄ':
            self.add_to_input(str(math.pi))
        elif button_text == 'e':
            self.add_to_input(str(math.e))
        elif button_text == 'n!':
            self.add_to_input('factorial(')
        elif button_text == 'ln':
            self.add_to_input('ln(')
        elif button_text == 'log':
            self.add_to_input('log10(')
        elif button_text == 'log2':
            self.add_to_input('log2(')
        elif button_text == 'exp':
            self.add_to_input('exp(')
        elif button_text == 'mod':
            self.add_to_input('%')
        elif button_text == 'abs':
            self.add_to_input('abs(')
        elif button_text == '1/x':
            self.add_to_input('1/(')
        elif button_text == 'floor':
            self.add_to_input('floor(')
        elif button_text == 'ceil':
            self.add_to_input('ceil(')
        elif button_text == '‚àõ':
            self.add_to_input('cbrt(')
        elif button_text == '^':
            self.add_to_input('**')
        elif button_text == '10^x':
            self.add_to_input('10**')
        elif button_text == '2^x':
            self.add_to_input('2**')
        elif button_text == '%':
            self.add_to_input('/100')
        elif button_text == 'ANS':
            if self.result:
                self.add_to_input(self.result)
        elif button_text == 'M+':
            self.memory_add()
        elif button_text == 'MR':
            self.memory_recall()
        elif button_text == 'MC':
            self.memory_clear()
        elif button_text == 'MS':
            self.memory_store()
        else:
            self.add_to_input(button_text)

    def add_to_input(self, value):
        self.current_input += value
        self.input_display.delete(0, tk.END)
        self.input_display.insert(0, self.current_input)

    def calculate(self):
        try:
            expression_text = self.current_input
            if re.search(r'[a-zA-Z]', expression_text):
                expression_text = self.convert_speech_to_math(
                    expression_text.lower()).strip()

            expression = expression_text.replace('√ó', '*').replace('√∑', '/')
            expression = expression.replace('^', '**')
            expression = expression.replace('=', '')

            expression = expression.replace('sqrt', 'math.sqrt')
            expression = expression.replace('sin', 'math.sin')
            expression = expression.replace('cos', 'math.cos')
            expression = expression.replace('tan', 'math.tan')
            expression = expression.replace('asin', 'math.asin')
            expression = expression.replace('acos', 'math.acos')
            expression = expression.replace('atan', 'math.atan')
            expression = expression.replace('sinh', 'math.sinh')
            expression = expression.replace('cosh', 'math.cosh')
            expression = expression.replace('tanh', 'math.tanh')
            expression = expression.replace('factorial', 'math.factorial')
            expression = expression.replace('log10', 'math.log10')
            expression = expression.replace('log2', 'math.log2')
            expression = expression.replace('log(', 'math.log10(')
            expression = expression.replace('ln', 'math.log')
            expression = expression.replace('exp', 'math.exp')
            expression = expression.replace('floor', 'math.floor')
            expression = expression.replace('ceil', 'math.ceil')

            def cbrt(value):
                return math.copysign(abs(value) ** (1.0 / 3.0), value)

            result = eval(expression, {"__builtins__": {}}, {
                          "math": math, "abs": abs, "cbrt": cbrt})

            if isinstance(result, float):
                if result.is_integer():
                    result = int(result)
                else:
                    result = round(result, 10)

            self.result = str(result)
            self.result_display.config(text=self.result)

            timestamp = datetime.now().strftime("%H:%M:%S")
            self.history.append(
                f"{timestamp}: {self.current_input} = {self.result}")

            self.current_input = str(result)
            self.input_display.delete(0, tk.END)
            self.input_display.insert(0, self.current_input)

        except Exception as e:
            error_msg = f"Error: {str(e)[:30]}"
            self.result_display.config(text=error_msg, fg='#e74c3c')

    def clear_all(self):
        self.current_input = ""
        self.result = ""
        self.input_display.delete(0, tk.END)
        self.result_display.config(text="0", fg='#2ecc71')

    def clear_entry(self):
        self.current_input = ""
        self.input_display.delete(0, tk.END)

    def backspace(self):
        self.current_input = self.current_input[:-1]
        self.input_display.delete(0, tk.END)
        self.input_display.insert(0, self.current_input)

    def memory_store(self):
        try:
            if self.result:
                self.memory = float(self.result)
            elif self.current_input:
                self.memory = float(self.current_input)
            messagebox.showinfo(
                "Memory", f"Value {self.memory} stored in memory")
        except:
            messagebox.showerror("Error", "Invalid value for memory")

    def memory_recall(self):
        self.add_to_input(str(self.memory))

    def memory_add(self):
        try:
            self.memory += float(self.result if self.result else 0)
        except:
            pass

    def memory_clear(self):
        self.memory = 0
        messagebox.showinfo("Memory", "Memory cleared")

    def negate(self):
        if self.current_input:
            if self.current_input[0] == '-':
                self.current_input = self.current_input[1:]
            else:
                self.current_input = '-' + self.current_input
            self.input_display.delete(0, tk.END)
            self.input_display.insert(0, self.current_input)

    def show_history(self):
        history_window = tk.Toplevel(self.root)
        history_window.title("Calculation History")
        history_window.geometry("400x400")
        history_window.configure(bg='#2c3e50')

        text_widget = scrolledtext.ScrolledText(
            history_window,
            wrap=tk.WORD,
            font=("Consolas", 10),
            bg='#34495e',
            fg='#ecf0f1',
            height=15
        )
        text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        if self.history:
            for item in reversed(self.history):
                text_widget.insert(tk.END, item + '\n')
        else:
            text_widget.insert(tk.END, "No history available")

        text_widget.config(state=tk.DISABLED)

        tk.Button(history_window, text="Close", command=history_window.destroy,
                  bg='#3498db', fg='white').pack(pady=10)

    def graph_expression(self):
        if not self.graphing_available:
            messagebox.showerror(
                "Graphing", "Graphing requires matplotlib. Install: pip install matplotlib")
            return

        expr = self.current_input.strip()
        if 'x' not in expr:
            expr = simpledialog.askstring(
                "Graph", "Enter function in x (e.g., sin(x) + x^2):")
            if not expr:
                return

        expr_np = self.to_numpy_expression(expr)
        x = np.linspace(self.graph_x_min, self.graph_x_max, self.graph_points)

        try:
            y = eval(expr_np, {"__builtins__": {}}, {"np": np, "x": x})
        except Exception as e:
            messagebox.showerror("Graphing error", f"Invalid expression: {e}")
            return

        graph_window = tk.Toplevel(self.root)
        graph_window.title("Function Graph")
        graph_window.geometry("700x500")
        graph_window.configure(bg='#2c3e50')

        fig = Figure(figsize=(6.5, 4.5), dpi=100)
        ax = fig.add_subplot(111)
        ax.plot(x, y)
        ax.set_xlabel("x")
        ax.set_ylabel("f(x)")
        ax.grid(True, alpha=0.3)

        canvas = FigureCanvasTkAgg(fig, master=graph_window)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    def to_numpy_expression(self, expr):
        expr = expr.replace('√ó', '*').replace('√∑', '/').replace('^', '**')
        expr = re.sub(r'\blog\(', 'log10(', expr, flags=re.IGNORECASE)
        expr = re.sub(r'\bpi\b', 'np.pi', expr, flags=re.IGNORECASE)
        expr = re.sub(r'\be\b', 'np.e', expr, flags=re.IGNORECASE)

        mapping = {
            'asin': 'np.arcsin',
            'acos': 'np.arccos',
            'atan': 'np.arctan',
            'sinh': 'np.sinh',
            'cosh': 'np.cosh',
            'tanh': 'np.tanh',
            'sin': 'np.sin',
            'cos': 'np.cos',
            'tan': 'np.tan',
            'log10': 'np.log10',
            'log2': 'np.log2',
            'ln': 'np.log',
            'exp': 'np.exp',
            'sqrt': 'np.sqrt',
            'cbrt': 'np.cbrt',
            'abs': 'np.abs',
            'floor': 'np.floor',
            'ceil': 'np.ceil'
        }

        for key in sorted(mapping.keys(), key=len, reverse=True):
            expr = re.sub(rf'\b{key}\(', f"{mapping[key]}(", expr)

        return expr


def main():
    log_startup("Starting application")
    try:
        root = tk.Tk()
        log_startup("Tk root created")

        def report_callback_exception(exc_type, exc_value, exc_traceback):
            log_startup("Tk callback exception:")
            log_startup(''.join(traceback.format_exception(
                exc_type, exc_value, exc_traceback)).strip())

        root.report_callback_exception = report_callback_exception

        def excepthook(exc_type, exc_value, exc_traceback):
            log_startup("Unhandled exception:")
            log_startup(''.join(traceback.format_exception(
                exc_type, exc_value, exc_traceback)).strip())

        sys.excepthook = excepthook

        app = AIEnhancedCalculator(root)
        log_startup("UI initialized, entering mainloop")
        root.mainloop()
        log_startup("Mainloop exited")
    except Exception:
        log_startup("Exception during startup:")
        log_startup(traceback.format_exc().strip())


if __name__ == "__main__":
    main()
