import tkinter as tk
from tkinter import scrolledtext, messagebox
import math
import re
import json
import os
import threading
import queue
from datetime import datetime
import random
from collections import deque

# --- VOICE RECOGNITION IMPORTS ---
try:
    import speech_recognition as sr
    import pyttsx3
    VOICE_FEATURES_AVAILABLE = True
except ImportError:
    VOICE_FEATURES_AVAILABLE = False
    print("Voice features disabled. Install: pip install SpeechRecognition pyttsx3")


class AIEnhancedCalculator:
    def __init__(self, root):
        self.root = root
        self.root.title("AI-Powered Smart Calculator with Voice")
        self.root.geometry("850x750")  # Increased height for voice controls
        self.root.configure(bg='#2c3e50')

        # Initialize variables
        self.current_input = ""
        self.result = ""
        self.memory = 0
        self.history = deque(maxlen=50)
        self.is_dark_mode = True
        self.is_listening = False
        self.voice_feedback = True

        # Voice recognition setup
        if VOICE_FEATURES_AVAILABLE:
            self.recognizer = sr.Recognizer()
            self.microphone = sr.Microphone()
            self.tts_engine = pyttsx3.init()
            # Configure TTS settings[citation:1]
            self.tts_engine.setProperty('rate', 150)  # Speaking speed
            self.tts_engine.setProperty('volume', 0.9)  # Volume level
        else:
            self.recognizer = None
            self.tts_engine = None

        # Create GUI
        self.setup_gui()
        self.bind_keyboard_events()

    def setup_gui(self):
        # Title
        title_label = tk.Label(
            self.root,
            text="üé§ AI-Powered Voice Calculator",
            font=("Arial", 18, "bold"),
            bg='#34495e',
            fg='#ecf0f1'
        )
        title_label.pack(pady=(10, 5), fill=tk.X)

        # Voice control frame
        voice_frame = tk.Frame(self.root, bg='#2c3e50')
        voice_frame.pack(fill=tk.X, padx=20, pady=(0, 10))

        if VOICE_FEATURES_AVAILABLE:
            self.voice_button = tk.Button(
                voice_frame,
                text="üé§ Start Voice Input",
                font=("Arial", 12, "bold"),
                bg='#9b59b6',
                fg='white',
                command=self.toggle_voice_input,
                height=2
            )
            self.voice_button.pack(side=tk.LEFT, padx=5,
                                   fill=tk.X, expand=True)

            self.feedback_button = tk.Button(
                voice_frame,
                text="üîä Voice Feedback: ON",
                font=("Arial", 10),
                bg='#3498db',
                fg='white',
                command=self.toggle_voice_feedback
            )
            self.feedback_button.pack(side=tk.LEFT, padx=5)

            # Voice status label
            self.voice_status = tk.Label(
                voice_frame,
                text="Voice: Ready",
                font=("Arial", 10),
                bg='#2c3e50',
                fg='#2ecc71'
            )
            self.voice_status.pack(side=tk.LEFT, padx=10)
        else:
            tk.Label(
                voice_frame,
                text="Voice features unavailable. Install: pip install SpeechRecognition pyttsx3",
                font=("Arial", 10),
                bg='#e74c3c',
                fg='white'
            ).pack(fill=tk.X, pady=5)

        # Display frame
        display_frame = tk.Frame(self.root, bg='#34495e')
        display_frame.pack(fill=tk.X, padx=20, pady=(0, 10))

        # Input display
        self.input_display = tk.Entry(
            display_frame,
            font=("Arial", 20),
            bd=5,
            relief=tk.RIDGE,
            justify=tk.RIGHT,
            bg='#ecf0f1',
            fg='#2c3e50'
        )
        self.input_display.pack(fill=tk.X, ipady=10, padx=10, pady=10)

        # Result display
        self.result_display = tk.Label(
            display_frame,
            text="0",
            font=("Arial", 24, "bold"),
            bg='#34495e',
            fg='#2ecc71',
            anchor=tk.E,
            height=2
        )
        self.result_display.pack(fill=tk.X, padx=10, pady=(0, 10))

        # Control buttons
        control_frame = tk.Frame(self.root, bg='#2c3e50')
        control_frame.pack(fill=tk.X, padx=20, pady=(0, 10))

        tk.Button(control_frame, text="Clear All", command=self.clear_all,
                  bg='#e74c3c', fg='white', font=("Arial", 10)).pack(side=tk.LEFT, padx=2)
        tk.Button(control_frame, text="History", command=self.show_history,
                  bg='#3498db', fg='white', font=("Arial", 10)).pack(side=tk.LEFT, padx=2)
        tk.Button(control_frame, text="Voice Help", command=self.show_voice_help,
                  bg='#9b59b6', fg='white', font=("Arial", 10)).pack(side=tk.LEFT, padx=2)

        # Main calculator buttons
        self.create_calculator_buttons()

    def create_calculator_buttons(self):
        button_frame = tk.Frame(self.root, bg='#2c3e50')
        button_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        # Button layout
        button_rows = [
            ['C', 'CE', '‚å´', '√∑', '‚àö', 'x¬≤', 'üé§'],
            ['7', '8', '9', '√ó', 'sin', 'cos', 'tan'],
            ['4', '5', '6', '-', 'œÄ', 'e', 'n!'],
            ['1', '2', '3', '+', '(', ')', '='],
            ['0', '.', '¬±', 'M+', 'MR', 'MC', 'MS']
        ]

        # Create buttons
        for row_idx, row in enumerate(button_rows):
            row_frame = tk.Frame(button_frame, bg='#2c3e50')
            row_frame.pack(fill=tk.BOTH, expand=True)

            for col_idx, text in enumerate(row):
                if text == '=':
                    btn_color = '#2ecc71'
                    text_color = 'white'
                elif text in ['C', 'CE']:
                    btn_color = '#e74c3c'
                    text_color = 'white'
                elif text in ['sin', 'cos', 'tan', '‚àö', 'œÄ', 'e', 'n!', 'x¬≤', 'üé§']:
                    btn_color = '#9b59b6'
                    text_color = 'white'
                elif text in ['M+', 'MR', 'MC', 'MS']:
                    btn_color = '#f39c12'
                    text_color = 'white'
                else:
                    btn_color = '#34495e'
                    text_color = '#ecf0f1'

                btn = tk.Button(
                    row_frame,
                    text=text,
                    font=("Arial", 14),
                    bg=btn_color,
                    fg=text_color,
                    bd=2,
                    relief=tk.RAISED,
                    command=lambda t=text: self.on_button_click(t)
                )
                btn.pack(side=tk.LEFT, fill=tk.BOTH,
                         expand=True, padx=2, pady=2)

    # --- VOICE RECOGNITION FUNCTIONS ---

    def toggle_voice_input(self):
        """Toggle voice listening mode[citation:3][citation:6]"""
        if not VOICE_FEATURES_AVAILABLE:
            messagebox.showerror("Error", "Voice features not available")
            return

        if not self.is_listening:
            self.is_listening = True
            self.voice_button.config(text="‚è∏ Stop Listening", bg='#e74c3c')
            self.voice_status.config(
                text="Listening... Speak now", fg='#f1c40f')
            self.root.update()

            # Start voice recognition in a separate thread
            voice_thread = threading.Thread(target=self.listen_and_process)
            voice_thread.daemon = True
            voice_thread.start()
        else:
            self.is_listening = False
            self.voice_button.config(text="üé§ Start Voice Input", bg='#9b59b6')
            self.voice_status.config(text="Voice: Ready", fg='#2ecc71')

    def listen_and_process(self):
        """Listen to microphone and process speech[citation:3]"""
        try:
            with self.microphone as source:
                # Adjust for ambient noise[citation:3]
                self.recognizer.adjust_for_ambient_noise(source, duration=0.5)
                self.speak("Listening")

                while self.is_listening:
                    try:
                        audio = self.recognizer.listen(
                            source, timeout=3, phrase_time_limit=5)
                        text = self.recognizer.recognize_google(audio)
                        self.process_voice_command(text)

                    except sr.WaitTimeoutError:
                        continue
                    except sr.UnknownValueError:
                        self.voice_status.config(
                            text="Could not understand", fg='#e74c3c')
                    except sr.RequestError as e:
                        self.voice_status.config(
                            text=f"API Error: {e}", fg='#e74c3c')

        except Exception as e:
            self.root.after(0, lambda: messagebox.showerror(
                "Voice Error", str(e)))

    def process_voice_command(self, spoken_text):
        """Convert spoken text to calculator input[citation:6]"""
        # Update status
        self.root.after(0, lambda: self.voice_status.config(
            text=f"Heard: {spoken_text[:30]}...", fg='#3498db'))

        # Convert natural language to math expressions
        converted_text = self.convert_speech_to_math(spoken_text.lower())

        # Add to calculator input
        self.root.after(0, lambda: self.add_to_input(converted_text))

        # Provide voice feedback
        if self.voice_feedback:
            self.speak(f"Entered {spoken_text}")

    def convert_speech_to_math(self, text):
        """Convert natural language to mathematical expressions"""
        conversions = {
            # Basic operations
            r'plus|\+': '+',
            r'minus|\-': '-',
            r'times|multiplied by|\*': '√ó',
            r'divided by|over|/': '√∑',
            r'squared|\^2': '**2',
            r'cubed|\^3': '**3',
            r'to the power of|\^': '**',

            # Numbers
            r'zero': '0', r'one': '1', r'two': '2', r'three': '3', r'four': '4',
            r'five': '5', r'six': '6', r'seven': '7', r'eight': '8', r'nine': '9',
            r'ten': '10', r'eleven': '11', r'twelve': '12', r'thirteen': '13',
            r'fourteen': '14', r'fifteen': '15', r'sixteen': '16', r'seventeen': '17',
            r'eighteen': '18', r'nineteen': '19', r'twenty': '20', r'thirty': '30',
            r'forty': '40', r'fifty': '50', r'sixty': '60', r'seventy': '70',
            r'eighty': '80', r'ninety': '90', r'hundred': '100',

            # Functions
            r'square root of|root of': 'sqrt(',
            r'sine of|sin of': 'sin(',
            r'cosine of|cos of': 'cos(',
            r'tangent of|tan of': 'tan(',
            r'log of|logarithm of': 'log(',
            r'natural log of|ln of': 'log(',
            r'factorial of|factorial': 'factorial(',
            r'absolute value of|absolute of': 'abs(',

            # Constants
            r'pi|pie': str(math.pi),
            r'euler|euler\'s number': str(math.e),

            # Commands
            r'equals|equal|=|calculate': '=',
            r'clear|reset': 'C',
            r'backspace|delete': '‚å´',
            r'open bracket|open parenthesis': '(',
            r'close bracket|close parenthesis': ')',
            r'point|decimal': '.',
            r'percent|percentage': '%',
            r'memory store': 'MS',
            r'memory recall': 'MR',
            r'memory clear': 'MC',
            r'add to memory': 'M+',
        }

        result = text
        for pattern, replacement in conversions.items():
            result = re.sub(pattern, replacement, result)

        # Remove extra words
        result = re.sub(
            r'\b(what is|compute|calculate|find|the|of|and)\b', '', result)
        result = re.sub(r'\s+', ' ', result).strip()

        return result + ' '

    def speak(self, text):
        """Convert text to speech[citation:1][citation:7]"""
        if self.tts_engine and self.voice_feedback:
            def speak_thread():
                try:
                    self.tts_engine.say(text)
                    self.tts_engine.runAndWait()
                except:
                    pass

            threading.Thread(target=speak_thread, daemon=True).start()

    def toggle_voice_feedback(self):
        """Toggle voice feedback on/off"""
        self.voice_feedback = not self.voice_feedback
        status = "ON" if self.voice_feedback else "OFF"
        self.feedback_button.config(text=f"üîä Voice Feedback: {status}")

    def show_voice_help(self):
        """Show voice command help"""
        help_text = """
        VOICE COMMANDS EXAMPLES:
        
        BASIC MATH:
        ‚Ä¢ "five plus three" ‚Üí 5+3
        ‚Ä¢ "ten minus four" ‚Üí 10-4
        ‚Ä¢ "six times seven" ‚Üí 6√ó7
        ‚Ä¢ "fifteen divided by three" ‚Üí 15√∑3
        ‚Ä¢ "two squared" ‚Üí 2**2
        ‚Ä¢ "three to the power of four" ‚Üí 3**4
        
        FUNCTIONS:
        ‚Ä¢ "square root of sixteen" ‚Üí sqrt(16)
        ‚Ä¢ "sine of thirty" ‚Üí sin(30)
        ‚Ä¢ "log of one hundred" ‚Üí log(100)
        ‚Ä¢ "factorial of five" ‚Üí factorial(5)
        
        CONSTANTS:
        ‚Ä¢ "pi" ‚Üí 3.14159...
        ‚Ä¢ "e" ‚Üí 2.71828...
        
        COMMANDS:
        ‚Ä¢ "equals" or "calculate" ‚Üí =
        ‚Ä¢ "clear" ‚Üí C
        ‚Ä¢ "backspace" ‚Üí ‚å´
        ‚Ä¢ "memory store" ‚Üí MS
        ‚Ä¢ "memory recall" ‚Üí MR
        
        TIP: Speak clearly and pause between commands.
        """

        help_window = tk.Toplevel(self.root)
        help_window.title("Voice Command Help")
        help_window.geometry("500x500")
        help_window.configure(bg='#2c3e50')

        text_widget = scrolledtext.ScrolledText(
            help_window,
            wrap=tk.WORD,
            font=("Consolas", 10),
            bg='#34495e',
            fg='#ecf0f1',
            height=25
        )
        text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        text_widget.insert(tk.END, help_text)
        text_widget.config(state=tk.DISABLED)

        tk.Button(help_window, text="Close", command=help_window.destroy,
                  bg='#3498db', fg='white').pack(pady=10)

    # --- EXISTING CALCULATOR FUNCTIONS (modified for voice) ---

    def bind_keyboard_events(self):
        # ... (existing bindings remain the same)
        # Bind 'v' key for voice input
        self.root.bind('v', lambda e: self.toggle_voice_input())
        self.root.bind('V', lambda e: self.toggle_voice_input())

    def on_button_click(self, button_text):
        if button_text == 'üé§':
            self.toggle_voice_input()
        # ... (rest of existing button handling remains the same)
        else:
            self.add_to_input(button_text)

    def add_to_input(self, value):
        self.current_input += value
        self.input_display.delete(0, tk.END)
        self.input_display.insert(0, self.current_input)

        # Auto-calculate if voice input ends with '='
        if value.strip().endswith('='):
            self.root.after(100, self.calculate)

    def calculate(self):
        try:
            expression = self.current_input.replace('√ó', '*').replace('√∑', '/')

            # Handle special functions
            expression = expression.replace('sqrt', 'math.sqrt')
            expression = expression.replace('sin', 'math.sin')
            expression = expression.replace('cos', 'math.cos')
            expression = expression.replace('tan', 'math.tan')
            expression = expression.replace('factorial', 'math.factorial')
            expression = expression.replace('log', 'math.log10')

            # Evaluate expression safely
            result = eval(expression, {"__builtins__": {}}, {
                          "math": math, "abs": abs})

            # Format result
            if isinstance(result, float):
                if result.is_integer():
                    result = int(result)
                else:
                    result = round(result, 10)

            self.result = str(result)
            self.result_display.config(text=self.result)

            # Add to history
            timestamp = datetime.now().strftime("%H:%M:%S")
            self.history.append(
                f"{timestamp}: {self.current_input} = {self.result}")

            # Voice announcement of result
            if self.voice_feedback and self.tts_engine:
                self.speak(f"The result is {self.result}")

            # Set result as new input
            self.current_input = str(result)
            self.input_display.delete(0, tk.END)
            self.input_display.insert(0, self.current_input)

        except Exception as e:
            error_msg = f"Error: {str(e)[:30]}"
            self.result_display.config(text=error_msg, fg='#e74c3c')
            if self.voice_feedback and self.tts_engine:
                self.speak("Calculation error")

    # ... (rest of existing calculator functions remain unchanged)
    def clear_all(self):
        self.current_input = ""
        self.result = ""
        self.input_display.delete(0, tk.END)
        self.result_display.config(text="0", fg='#2ecc71')

    def clear_entry(self):
        self.current_input = ""
        self.input_display.delete(0, tk.END)

    def backspace(self):
        self.current_input = self.current_input[:-1]
        self.input_display.delete(0, tk.END)
        self.input_display.insert(0, self.current_input)

    def memory_store(self):
        try:
            if self.result:
                self.memory = float(self.result)
            elif self.current_input:
                self.memory = float(self.current_input)
            messagebox.showinfo(
                "Memory", f"Value {self.memory} stored in memory")
        except:
            messagebox.showerror("Error", "Invalid value for memory")

    def memory_recall(self):
        self.add_to_input(str(self.memory))

    def memory_add(self):
        try:
            self.memory += float(self.result if self.result else 0)
        except:
            pass

    def memory_clear(self):
        self.memory = 0
        messagebox.showinfo("Memory", "Memory cleared")

    def negate(self):
        if self.current_input:
            if self.current_input[0] == '-':
                self.current_input = self.current_input[1:]
            else:
                self.current_input = '-' + self.current_input
            self.input_display.delete(0, tk.END)
            self.input_display.insert(0, self.current_input)

    def show_history(self):
        history_window = tk.Toplevel(self.root)
        history_window.title("Calculation History")
        history_window.geometry("400x400")
        history_window.configure(bg='#2c3e50')

        text_widget = scrolledtext.ScrolledText(
            history_window,
            wrap=tk.WORD,
            font=("Consolas", 10),
            bg='#34495e',
            fg='#ecf0f1',
            height=15
        )
        text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        if self.history:
            for item in reversed(self.history):
                text_widget.insert(tk.END, item + '\n')
        else:
            text_widget.insert(tk.END, "No history available")

        text_widget.config(state=tk.DISABLED)

        tk.Button(history_window, text="Close", command=history_window.destroy,
                  bg='#3498db', fg='white').pack(pady=10)


def main():
    root = tk.Tk()
    app = AIEnhancedCalculator(root)
    root.mainloop()


if __name__ == "__main__":
    main()
